#include <Arduino.h>
#include <WiFi.h>
#include <WiFiProv.h>
#include <Wire.h>
#include <U8g2lib.h>

// ===== OLED =====
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE, 6, 5);
int width = 72;
int height = 39;
int xOffset = 28;
int yOffset = 25;

// ===== WiFi Provisioning (BLE sin QR) =====
static char g_serviceName[20] = "PROV_QTPY_C3";
static const char *POP        = "abcd1234";     // PIN PoP para Security 1
static const char *SERVICE_KEY = NULL;

const int FORCE_BTN = 0; // GPIO0 / BOOT

// ===== Estados de pantalla =====
enum DispState : uint8_t {
  DISP_DESCONECTADO = 0,
  DISP_SETUP,
  DISP_CONECTANDO,
  DISP_CONECTADO
};
volatile DispState g_dispState = DISP_DESCONECTADO;
volatile bool g_showProvisioningInfo = false;

// Animación (puntos y fades)
uint32_t lastAnimMs = 0;
volatile uint8_t dots = 0;
volatile bool pendingFadeToConnected = false;   // Transición B2 → Conectado tras GOT_IP
const uint16_t fadeMs = 120;           // Duración del fade (ms)

// ===== Helpers OLED =====
static void drawFrame() {
  u8g2.drawFrame(xOffset, yOffset, width, height);
}

static void drawProvisioningInstructions() {
  const int16_t baseX = xOffset + 4;
  const int16_t baseY = yOffset + 12;

  u8g2.setFont(u8g2_font_5x8_tf);
  u8g2.setCursor(baseX, baseY);
  u8g2.print("Configura con app");
  u8g2.setCursor(baseX, baseY + 9);
  u8g2.print("Servicio:");
  u8g2.setCursor(baseX, baseY + 18);
  u8g2.print(g_serviceName);
  u8g2.setCursor(baseX, baseY + 27);
  u8g2.print("PoP: ");
  u8g2.print(POP);
}

static void drawCenteredText(const char* text) {
  u8g2.setFont(u8g2_font_6x10_tf); // texto pequeño
  int16_t tw = u8g2.getStrWidth(text);
  int16_t tx = xOffset + (width - tw) / 2;
  int16_t ty = yOffset + (height / 2) + 4;
  u8g2.drawStr(tx, ty, text);
}

// Fade “premium”: borra SOLO el área interior (marco permanece)
static void fadeTextAreaOnly(uint16_t ms) {
  u8g2.setDrawColor(0);
  u8g2.drawBox(xOffset + 1, yOffset + 1, width - 2, height - 2);
  u8g2.setDrawColor(1);
  drawFrame();
  u8g2.sendBuffer();
  delay(ms);
}

static void oledShow() {
  u8g2.clearBuffer();
  drawFrame();

  char buf[26] = {0};
  switch (g_dispState) {
    case DISP_DESCONECTADO:
      drawCenteredText("Desconectado");
      break;
    case DISP_SETUP:
      if (g_showProvisioningInfo) {
        drawProvisioningInstructions();
      } else {
        snprintf(buf, sizeof(buf), "Setup%.*s", (dots % 3) + 1, "...");
        drawCenteredText(buf);
      }
      break;
    case DISP_CONECTANDO:
      snprintf(buf, sizeof(buf), "Conectando%.*s", (dots % 3) + 1, "...");
      drawCenteredText(buf);
      break;
    case DISP_CONECTADO:
      drawCenteredText("Conectado");
      break;
  }

  u8g2.sendBuffer();
}

// ===== Event Handler WiFi / Provisioning =====
void SysProvEvent(arduino_event_t *sys_event) {
  switch (sys_event->event_id) {
    case ARDUINO_EVENT_WIFI_STA_CONNECTED:
      Serial.println("[WIFI] STA_CONNECTED");
      g_dispState = DISP_CONECTANDO;
      g_showProvisioningInfo = false;
      break;

    case ARDUINO_EVENT_WIFI_STA_GOT_IP:
      Serial.print("[WIFI] GOT_IP: ");
      Serial.println(IPAddress(sys_event->event_info.got_ip.ip_info.ip.addr));
      // B2: no cambiar en el mismo instante; aplicamos fade en el siguiente tick
      pendingFadeToConnected = true;
      break;

    case ARDUINO_EVENT_WIFI_STA_DISCONNECTED:
      Serial.printf("[WIFI] DISCONNECTED reason=%d\n",
                    sys_event->event_info.wifi_sta_disconnected.reason);
      // SIN reconexiones automáticas: queda desconectado
      g_dispState = DISP_DESCONECTADO;
      g_showProvisioningInfo = false;
      oledShow();
      break;

    case ARDUINO_EVENT_PROV_START:
      Serial.println("[PROV] Provisioning iniciado (BLE)");
      g_dispState = DISP_SETUP;
      dots = 0;
      g_showProvisioningInfo = true;
      oledShow();
      break;

    case ARDUINO_EVENT_PROV_CRED_RECV:
      Serial.printf("[PROV] Credenciales recibidas: SSID=%s, PASS=%s\n",
                    sys_event->event_info.prov_cred_recv.ssid,
                    sys_event->event_info.prov_cred_recv.password);
      // Encendemos Wi-Fi recién aquí (durante provisioning estuvo OFF)
      WiFi.mode(WIFI_MODE_STA);
      g_dispState = DISP_CONECTANDO;
      dots = 0;
      g_showProvisioningInfo = false;
      oledShow();
      break;

    case ARDUINO_EVENT_PROV_CRED_FAIL:
      Serial.printf("[PROV] Credenciales FALLARON (reason=%d)\n",
                    sys_event->event_info.prov_fail_reason);
      g_dispState = DISP_SETUP;
      dots = 0;
      g_showProvisioningInfo = true;
      oledShow();
      break;

    case ARDUINO_EVENT_PROV_CRED_SUCCESS:
      Serial.println("[PROV] Credenciales OK, conectando...");
      g_dispState = DISP_CONECTANDO;
      dots = 0;
      g_showProvisioningInfo = false;
      oledShow();
      break;

    case ARDUINO_EVENT_PROV_END:
      Serial.println("[PROV] Provisioning finalizado");
      break;
  }
}

// ===== Iniciar BLE Provisioning con app (Security 1) =====
static void startBleProvisioning() {
  Serial.println("\n=== BLE Provisioning Security 1 (sin QR) ===");

  // Limpiar estados visuales y de transición
  pendingFadeToConnected = false;
  dots = 0;
  g_showProvisioningInfo = true;

  // Importante: WiFi se mantiene OFF (WIFI_MODE_NULL) durante todo el provisioning
  // El handler WiFi.onEvent(...) está registrado SOLO en setup()

  WiFiProv.beginProvision(
      WIFI_PROV_SCHEME_BLE,
      WIFI_PROV_SCHEME_HANDLER_FREE_BTDM,
      WIFI_PROV_SECURITY_1,
      POP,
      g_serviceName,
      SERVICE_KEY);

  Serial.println("Usa tu app para conectarte vía BLE:");
  Serial.printf("  Servicio: %s\n", g_serviceName);
  Serial.printf("  PoP: %s\n", POP);

  // Fade al entrar a Setup (tu elección)
  fadeTextAreaOnly(fadeMs);
  g_dispState = DISP_SETUP;
  oledShow();
}

static void buildServiceName() {
  uint8_t mac[6];
  WiFi.macAddress(mac);
  snprintf(g_serviceName, sizeof(g_serviceName), "PROV_%02X%02X%02X", mac[3], mac[4], mac[5]);
}

void setup() {
  Serial.begin(9600);
  delay(200);

  buildServiceName();
  Serial.printf("Servicio BLE asignado: %s\n", g_serviceName);
  Serial.printf("PoP configurado: %s\n", POP);

  // OLED
  u8g2.begin();
  u8g2.setContrast(255);
  u8g2.setBusClock(400000);

  pinMode(FORCE_BTN, INPUT_PULLUP);

  // Registrar eventos SOLO una vez
  WiFi.onEvent(SysProvEvent);

  Serial.println("Arrancando... BOOT 5s = Borrar WiFi + WiFi OFF + Provisioning");

  // Estado inicial
  g_dispState = DISP_DESCONECTADO;
  oledShow();

  // Intento ÚNICO de conexión si hay credenciales guardadas
  WiFi.mode(WIFI_MODE_STA);
  WiFi.begin();
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 5000) {
    g_dispState = DISP_CONECTANDO;
    if (millis() - lastAnimMs > 350) {
      lastAnimMs = millis();
      dots++;
      oledShow();
    }
    delay(50);
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("Conectado a: "); Serial.println(WiFi.SSID());
    Serial.print("IP: "); Serial.println(WiFi.localIP());
    // B2: aplicaremos fade en el próximo tick para mostrar “Conectado”
    pendingFadeToConnected = true;
    lastAnimMs = 0;
  } else {
    Serial.println("Sin WiFi o no conectó al arrancar.");
    g_dispState = DISP_DESCONECTADO;
    oledShow();
  }
}

void loop() {
  // === Gestión del botón BOOT (5 s) — acción INMEDIATA al cumplir 5 s ===
  static bool pressed = false;
  static uint32_t pressStart = 0;

  bool btn = (digitalRead(FORCE_BTN) == LOW);

  if (btn && !pressed) {
    pressed = true;
    pressStart = millis();
  }
  // No hacemos nada cuando suelta; acción es inmediata a los 5s
  if (pressed && (millis() - pressStart > 5000)) {
    pressed = false;
    Serial.println("BOOT 5s → Borrar WiFi + WiFi OFF + Provisioning");

    // 1) Borrar SIEMPRE credenciales
    WiFi.disconnect(true, true);

    // 2) APAGAR completamente WiFi para evitar eventos residuales
    WiFi.mode(WIFI_MODE_NULL);
    delay(150);

    // 3) Reset de estados de UI/transición
    pendingFadeToConnected = false;
    dots = 0;

    // 4) Entrar a provisioning limpio (BLE + app)
    startBleProvisioning();
  }

  // === Animación de texto y transición B2 con fade ===
  bool animateSetup = (g_dispState == DISP_SETUP) && !g_showProvisioningInfo;
  bool animateConnecting = (g_dispState == DISP_CONECTANDO);
  if (animateSetup || animateConnecting) {
    if (millis() - lastAnimMs > 350) {
      lastAnimMs = millis();
      dots++;

      // Si ya hay IP pendiente de mostrar → fade premium y Conectado
      if (pendingFadeToConnected) {
        pendingFadeToConnected = false;
        fadeTextAreaOnly(fadeMs);
        g_dispState = DISP_CONECTADO;
        dots = 0;
      }
      oledShow();
    }
  }

  delay(20);
}
